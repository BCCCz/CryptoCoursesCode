# 实验二 基于公钥体制的加密和数字签名实现

## 一. 实验原理

数字签名相当于现实世界中的盖章、签名的功能在计算机世界中进行实现的技术。数字签名可以识别篡改、伪装、防止抵赖。

在数字签名中，有 2 种行为：

- 生成消息签名的行为
- 验证消息签名的行为

**生成消息签名**的人是由消息发送者完成的，也称为“对消息签名”。生成签名就是根据消息内容计算数字签名的值。

**验证数字签名**的人是第三方。第三方验证消息的来源是否属于发送者。验证结果可以是成功，也可以是失败。

**数字签名对签名密钥和验证密钥进行了区分，使用验证密钥是无法生成签名的**。签名密钥只能由签名人持有，而验证密钥则是任何需要验证签名的人都可以持有。

|              |         私钥         |            公钥            |
| :----------: | :------------------: | :------------------------: |
|   公钥密钥   |   接收者解密时使用   |      发送者加密时使用      |
|   数字签名   | 签名者生成签名时使用 |    验证者验证签名时使用    |
| 谁持有密钥？ |       个人持有       | 只要需要，任何人都可以持有 |

严格的来说，RSA 算法中公钥加密和数字签名正好是完全相反的关系，但是在其他公钥算法中有可能和数字签名不是完全相反的关系。

有两种生成和验证数字签名的方法：

- 直接对消息签名的方法
- 对消息的散列值签名的方法

对于两种方法一半都会先hash再签名，原因如下：

- 用Hash函数缩短message长度，减少签名时间损耗



1.用 RSA 生成签名

```c
签名 = 消息^D mod N (用 RSA 生成签名)
```

上面的 D 和 N 就是签名者的私钥。签名就是对消息的 D 次方求 mod N 的结果。

2. 用 RSA 验证签名

```c
由签名求得的消息 = 签名^E mod N (用 RSA 验证签名)
```

上面的 E 和 N 就是签名者的公钥。验证者计算签名的 E 次方并求 mod N，得到“由签名求得的消息”。将这个消息和发送者直接发过来的消息进行对比，如果一致就验证成功，不一致就验证失败。



## 二.代码实现

### 1.主要算法

1. 扩展欧几里得

```python
#扩展欧几里得求最大公约数
def Euclid(a,b):
    x1, x2, x3 = 1, 0, a
    y1, y2, y3 = 0, 1, b
    while y3 != 0:
        Q = x3//y3
        t1,t2,t3 = x1-Q*y1,x2-Q*y2,x3-Q*y3
        x1,x2,x3 = y1,y2,y3
        y1,y2,y3 = t1,t2,t3
    return x1
```

2. 大素数生成

```python
#大素数生成
def generateLargePrime():
    while True:
        num = random.randrange(2 ** (1024 - 1), 2 ** 1024)
        if is_prime(num):
            return num
```

3. 快速幂取模

```python
# 快速幂取模
def multimod(a, k, n):
    ans = 1
    while k != 0:
        if k % 2:
            ans = (ans % n) * (a % n) % n
        a = (a % n) * (a % n) % n
        k = k // 2
    return ans
```

## 2.运行函数

hash函数选取SHA256，调用Hashlib

其余算法均自行实现

```python
if __name__ == '__main__':
    p = generateLargePrime()
    q = generateLargePrime()
    n = p*q
    phi = (p-1)*(q-1)
    e = mpz(65537) #公钥
    d = Euclid(e, phi) #私钥

    message = b'It was the best of times, it was the worst of times, it was the age of wisdom, ' \
              b'it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, ' \
              b'it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair'

    sha256 = hashlib.sha256()
    sha256.update(message)

    #先Hash
    Hash = sha256.digest()
    #再用私钥加密
    C = bytes_to_long(Hash)
    signature1 = multimod(C,d,n)

    #公钥解密
    M = multimod(signature1,e,n)
    text = long_to_bytes(M)

    #相关参数输出
    print('Large prime number P:',p)
    print('Large prime number Q:',q)
    print('N:',n)
    print('Private key:',d)
    print('Public key:',e)
    print('message:',message)
    print('Message_Sha256_Digest:',Hash)
    print('Signature_Text:',signature1)

    if text == Hash:
        print('Right Signature')
    else:
        print('Flase')
```



## 三.运行结果

![](https://gitee.com/youngbc/photobucket/raw/master//img/20210510170535.png)





和其他方式对比：https://halfrost.com/digital_signature/